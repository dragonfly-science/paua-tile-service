import {
  Event_default,
  Layer_default as Layer_default2,
  apply,
  asArray,
  compose,
  create,
  fromString,
  isStringColor,
  reset,
  rotate,
  scale
} from "./chunk-B7O6DQJA.js";
import {
  EventType_default as EventType_default2,
  Layer_default,
  Property_default
} from "./chunk-SAM5HEAG.js";
import {
  DataTile_default
} from "./chunk-BY537VWO.js";
import {
  IMAGE_SMOOTHING_DISABLED,
  Tile_default
} from "./chunk-7XTKNVWU.js";
import {
  ImageTile_default
} from "./chunk-UGO337HH.js";
import {
  SAFARI_BUG_237906,
  createCanvasContext2D
} from "./chunk-A7VVAPMN.js";
import {
  LRUCache_default,
  TileRange_default,
  TileState_default,
  createOrUpdate,
  getKey,
  toSize
} from "./chunk-MUH32Y7Q.js";
import {
  State_default
} from "./chunk-OIGY3JBW.js";
import {
  Disposable_default,
  EventType_default,
  Target_default,
  numberSafeCompareFunction
} from "./chunk-CVXS23VU.js";
import {
  fromUserExtent,
  log2
} from "./chunk-USIUSUQK.js";
import {
  assert,
  assign,
  clear,
  containsCoordinate,
  getIntersection,
  getUid,
  isEmpty2 as isEmpty
} from "./chunk-2UVQ5S5W.js";
import "./chunk-WWO6H54A.js";

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BaseTileLayer = function(_super) {
  __extends(BaseTileLayer2, _super);
  function BaseTileLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.setPreload(options.preload !== void 0 ? options.preload : 0);
    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
    return _this;
  }
  BaseTileLayer2.prototype.getPreload = function() {
    return this.get(TileProperty_default.PRELOAD);
  };
  BaseTileLayer2.prototype.setPreload = function(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  };
  BaseTileLayer2.prototype.getUseInterimTilesOnError = function() {
    return this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR);
  };
  BaseTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };
  BaseTileLayer2.prototype.getData = function(pixel) {
    return _super.prototype.getData.call(this, pixel);
  };
  return BaseTileLayer2;
}(Layer_default);
var BaseTile_default = BaseTileLayer;

// node_modules/ol/webgl.js
var ARRAY_BUFFER = 34962;
var ELEMENT_ARRAY_BUFFER = 34963;
var STREAM_DRAW = 35040;
var STATIC_DRAW = 35044;
var DYNAMIC_DRAW = 35048;
var UNSIGNED_BYTE = 5121;
var UNSIGNED_SHORT = 5123;
var UNSIGNED_INT = 5125;
var FLOAT = 5126;
var CONTEXT_IDS = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function getContext(canvas, opt_attributes) {
  var attributes = assign({
    preserveDrawingBuffer: true,
    antialias: SAFARI_BUG_237906 ? false : true
  }, opt_attributes);
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], attributes);
      if (context) {
        return context;
      }
    } catch (e) {
    }
  }
  return null;
}

// node_modules/ol/webgl/Buffer.js
var BufferUsage = {
  STATIC_DRAW,
  STREAM_DRAW,
  DYNAMIC_DRAW
};
var WebGLArrayBuffer = function() {
  function WebGLArrayBuffer2(type, opt_usage) {
    this.array = null;
    this.type = type;
    assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);
    this.usage = opt_usage !== void 0 ? opt_usage : BufferUsage.STATIC_DRAW;
  }
  WebGLArrayBuffer2.prototype.ofSize = function(size) {
    this.array = new (getArrayClassForType(this.type))(size);
  };
  WebGLArrayBuffer2.prototype.fromArray = function(array) {
    var arrayClass = getArrayClassForType(this.type);
    this.array = arrayClass.from ? arrayClass.from(array) : new arrayClass(array);
  };
  WebGLArrayBuffer2.prototype.fromArrayBuffer = function(buffer) {
    this.array = new (getArrayClassForType(this.type))(buffer);
  };
  WebGLArrayBuffer2.prototype.getType = function() {
    return this.type;
  };
  WebGLArrayBuffer2.prototype.getArray = function() {
    return this.array;
  };
  WebGLArrayBuffer2.prototype.getUsage = function() {
    return this.usage;
  };
  WebGLArrayBuffer2.prototype.getSize = function() {
    return this.array ? this.array.length : 0;
  };
  return WebGLArrayBuffer2;
}();
function getArrayClassForType(type) {
  switch (type) {
    case ARRAY_BUFFER:
      return Float32Array;
    case ELEMENT_ARRAY_BUFFER:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
var Buffer_default = WebGLArrayBuffer;

// node_modules/ol/webgl/TileTexture.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function bindAndConfigure(gl, texture, interpolate) {
  var resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
}
function uploadImageTexture(gl, texture, image, interpolate) {
  bindAndConfigure(gl, texture, interpolate);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
}
function uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {
  var gl = helper.getGL();
  var textureType;
  var canInterpolate;
  if (data instanceof Float32Array) {
    textureType = gl.FLOAT;
    helper.getExtension("OES_texture_float");
    var extension = helper.getExtension("OES_texture_float_linear");
    canInterpolate = extension !== null;
  } else {
    textureType = gl.UNSIGNED_BYTE;
    canInterpolate = true;
  }
  bindAndConfigure(gl, texture, interpolate && canInterpolate);
  var bytesPerRow = data.byteLength / size[1];
  var unpackAlignment = 1;
  if (bytesPerRow % 8 === 0) {
    unpackAlignment = 8;
  } else if (bytesPerRow % 4 === 0) {
    unpackAlignment = 4;
  } else if (bytesPerRow % 2 === 0) {
    unpackAlignment = 2;
  }
  var format;
  switch (bandCount) {
    case 1: {
      format = gl.LUMINANCE;
      break;
    }
    case 2: {
      format = gl.LUMINANCE_ALPHA;
      break;
    }
    case 3: {
      format = gl.RGB;
      break;
    }
    case 4: {
      format = gl.RGBA;
      break;
    }
    default: {
      throw new Error("Unsupported number of bands: ".concat(bandCount));
    }
  }
  var oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
}
var pixelContext = null;
function createPixelContext() {
  var canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  pixelContext = canvas.getContext("2d");
}
var TileTexture = function(_super) {
  __extends2(TileTexture2, _super);
  function TileTexture2(options) {
    var _this = _super.call(this) || this;
    _this.tile;
    _this.textures = [];
    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
    _this.size = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));
    _this.tilePixelRatio_ = options.tilePixelRatio || 1;
    _this.gutter_ = options.gutter || 0;
    _this.bandCount = NaN;
    _this.helper_ = options.helper;
    var coords = new Buffer_default(ARRAY_BUFFER, STATIC_DRAW);
    coords.fromArray([
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]);
    _this.helper_.flushBufferData(coords);
    _this.coords = coords;
    _this.setTile(options.tile);
    return _this;
  }
  TileTexture2.prototype.setTile = function(tile) {
    if (tile !== this.tile) {
      if (this.tile) {
        this.tile.removeEventListener(EventType_default.CHANGE, this.handleTileChange_);
      }
      this.tile = tile;
      this.textures.length = 0;
      this.loaded = tile.getState() === TileState_default.LOADED;
      if (this.loaded) {
        this.uploadTile_();
      } else {
        if (tile instanceof ImageTile_default) {
          var image = tile.getImage();
          if (image instanceof Image && !image.crossOrigin) {
            image.crossOrigin = "anonymous";
          }
        }
        tile.addEventListener(EventType_default.CHANGE, this.handleTileChange_);
      }
    }
  };
  TileTexture2.prototype.uploadTile_ = function() {
    var helper = this.helper_;
    var gl = helper.getGL();
    var tile = this.tile;
    if (tile instanceof ImageTile_default || tile instanceof Tile_default) {
      var image = tile.getImage();
      if (this.gutter_ !== 0) {
        var gutter = this.tilePixelRatio_ * this.gutter_;
        var width = Math.round(image.width - 2 * gutter);
        var height = Math.round(image.height - 2 * gutter);
        var context = createCanvasContext2D(width, height);
        if (!tile.interpolate) {
          assign(context, IMAGE_SMOOTHING_DISABLED);
        }
        context.drawImage(image, gutter, gutter, width, height, 0, 0, width, height);
        image = context.canvas;
      }
      var texture = gl.createTexture();
      this.textures.push(texture);
      this.bandCount = 4;
      uploadImageTexture(gl, texture, image, tile.interpolate);
      return;
    }
    var pixelSize = [
      this.size[0] * this.tilePixelRatio_,
      this.size[1] * this.tilePixelRatio_
    ];
    var data = tile.getData();
    var isFloat = data instanceof Float32Array;
    var pixelCount = pixelSize[0] * pixelSize[1];
    var DataType = isFloat ? Float32Array : Uint8Array;
    var bytesPerElement = DataType.BYTES_PER_ELEMENT;
    var bytesPerRow = data.byteLength / pixelSize[1];
    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
    var textureCount = Math.ceil(this.bandCount / 4);
    if (textureCount === 1) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      uploadDataTexture(helper, texture, data, pixelSize, this.bandCount, tile.interpolate);
      return;
    }
    var textureDataArrays = new Array(textureCount);
    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;
      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
    }
    var dataIndex = 0;
    var rowOffset = 0;
    var colCount = pixelSize[0] * this.bandCount;
    for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
      for (var colIndex = 0; colIndex < colCount; ++colIndex) {
        var dataValue = data[rowOffset + colIndex];
        var pixelIndex = Math.floor(dataIndex / this.bandCount);
        var bandIndex = colIndex % this.bandCount;
        var textureIndex = Math.floor(bandIndex / 4);
        var textureData = textureDataArrays[textureIndex];
        var bandCount = textureData.length / pixelCount;
        var textureBandIndex = bandIndex % 4;
        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;
        ++dataIndex;
      }
      rowOffset += bytesPerRow / bytesPerElement;
    }
    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = this.textures[textureIndex];
      var textureData = textureDataArrays[textureIndex];
      var bandCount = textureData.length / pixelCount;
      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile.interpolate);
    }
  };
  TileTexture2.prototype.handleTileChange_ = function() {
    if (this.tile.getState() === TileState_default.LOADED) {
      this.loaded = true;
      this.uploadTile_();
      this.dispatchEvent(EventType_default.CHANGE);
    }
  };
  TileTexture2.prototype.disposeInternal = function() {
    var gl = this.helper_.getGL();
    this.helper_.deleteBuffer(this.coords);
    for (var i = 0; i < this.textures.length; ++i) {
      gl.deleteTexture(this.textures[i]);
    }
    this.tile.removeEventListener(EventType_default.CHANGE, this.handleTileChange_);
  };
  TileTexture2.prototype.getPixelData = function(col, row) {
    if (!this.loaded) {
      return null;
    }
    col = Math.floor(this.tilePixelRatio_ * col);
    row = Math.floor(this.tilePixelRatio_ * row);
    if (this.tile instanceof DataTile_default) {
      var data_1 = this.tile.getData();
      var pixelsPerRow = Math.floor(this.tilePixelRatio_ * this.size[0]);
      if (data_1 instanceof DataView) {
        var bytesPerPixel = data_1.byteLength / (this.size[0] * this.size[1]);
        var offset_1 = row * pixelsPerRow * bytesPerPixel + col * bytesPerPixel;
        var buffer = data_1.buffer.slice(offset_1, offset_1 + bytesPerPixel);
        return new DataView(buffer);
      }
      var offset = row * pixelsPerRow * this.bandCount + col * this.bandCount;
      return data_1.slice(offset, offset + this.bandCount);
    }
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    var data;
    var image = this.tile.getImage();
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return null;
    }
    return data;
  };
  return TileTexture2;
}(Target_default);
var TileTexture_default = TileTexture;

// node_modules/ol/webgl/ContextEventType.js
var ContextEventType_default = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
};

// node_modules/ol/webgl/PostProcessingPass.js
var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";
var WebGLPostProcessingPass = function() {
  function WebGLPostProcessingPass2(options) {
    this.gl_ = options.webGlContext;
    var gl = this.gl_;
    this.scaleRatio_ = options.scaleRatio || 1;
    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;
    this.frameBuffer_ = gl.createFramebuffer();
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_);
    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, "a_position");
    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_screenSize");
    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_opacity");
    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_image");
    this.uniforms_ = [];
    options.uniforms && Object.keys(options.uniforms).forEach(function(name) {
      this.uniforms_.push({
        value: options.uniforms[name],
        location: gl.getUniformLocation(this.renderTargetProgram_, name)
      });
    }.bind(this));
  }
  WebGLPostProcessingPass2.prototype.getGL = function() {
    return this.gl_;
  };
  WebGLPostProcessingPass2.prototype.init = function(frameState) {
    var gl = this.getGL();
    var textureSize = [
      gl.drawingBufferWidth * this.scaleRatio_,
      gl.drawingBufferHeight * this.scaleRatio_
    ];
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
    gl.viewport(0, 0, textureSize[0], textureSize[1]);
    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
      this.renderTargetTextureSize_ = textureSize;
      var level = 0;
      var internalFormat = gl.RGBA;
      var border = 0;
      var format = gl.RGBA;
      var type = gl.UNSIGNED_BYTE;
      var data = null;
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
    }
  };
  WebGLPostProcessingPass2.prototype.apply = function(frameState, nextPass, preCompose, postCompose) {
    var gl = this.getGL();
    var size = frameState.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
    if (!nextPass) {
      var canvasId = getUid(gl.canvas);
      if (!frameState.renderTargets[canvasId]) {
        var attributes = gl.getContextAttributes();
        if (attributes && attributes.preserveDrawingBuffer) {
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        frameState.renderTargets[canvasId] = true;
      }
    }
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.useProgram(this.renderTargetProgram_);
    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
    gl.uniform1i(this.renderTargetTextureLocation_, 0);
    var opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);
    this.applyUniforms(frameState);
    if (preCompose) {
      preCompose(gl, frameState);
    }
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    if (postCompose) {
      postCompose(gl, frameState);
    }
  };
  WebGLPostProcessingPass2.prototype.getFrameBuffer = function() {
    return this.frameBuffer_;
  };
  WebGLPostProcessingPass2.prototype.applyUniforms = function(frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 1;
    this.uniforms_.forEach(function(uniform) {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (value instanceof ImageData) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(uniform.location, textureSlot++);
      } else if (Array.isArray(value)) {
        switch (value.length) {
          case 2:
            gl.uniform2f(uniform.location, value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(uniform.location, value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(uniform.location, value);
      }
    });
  };
  return WebGLPostProcessingPass2;
}();
var PostProcessingPass_default = WebGLPostProcessingPass;

// node_modules/ol/vec/mat4.js
function create2() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function fromTransform(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
}

// node_modules/ol/webgl/Helper.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DefaultUniform = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  OFFSET_SCALE_MATRIX: "u_offsetScaleMatrix",
  OFFSET_ROTATION_MATRIX: "u_offsetRotateMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution"
};
var AttributeType = {
  UNSIGNED_BYTE,
  UNSIGNED_SHORT,
  UNSIGNED_INT,
  FLOAT
};
var canvasCache = {};
function getSharedCanvasCacheKey(key) {
  return "shared/" + key;
}
var uniqueCanvasCacheKeyCount = 0;
function getUniqueCanvasCacheKey() {
  var key = "unique/" + uniqueCanvasCacheKeyCount;
  uniqueCanvasCacheKeyCount += 1;
  return key;
}
function getCanvas(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    var canvas = document.createElement("canvas");
    canvas.style.position = "absolute";
    canvas.style.left = "0";
    cacheItem = { users: 0, canvas };
    canvasCache[key] = cacheItem;
  }
  cacheItem.users += 1;
  return cacheItem.canvas;
}
function releaseCanvas(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    return;
  }
  cacheItem.users -= 1;
  if (cacheItem.users > 0) {
    return;
  }
  var canvas = cacheItem.canvas;
  var gl = getContext(canvas);
  var extension = gl.getExtension("WEBGL_lose_context");
  if (extension) {
    extension.loseContext();
  }
  delete canvasCache[key];
}
var WebGLHelper = function(_super) {
  __extends3(WebGLHelper2, _super);
  function WebGLHelper2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options || {};
    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);
    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);
    _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
    _this.canvas_ = getCanvas(_this.canvasCacheKey_);
    _this.gl_ = getContext(_this.canvas_);
    _this.bufferCache_ = {};
    _this.extensionCache_ = {};
    _this.currentProgram_ = null;
    _this.canvas_.addEventListener(ContextEventType_default.LOST, _this.boundHandleWebGLContextLost_);
    _this.canvas_.addEventListener(ContextEventType_default.RESTORED, _this.boundHandleWebGLContextRestored_);
    _this.offsetRotateMatrix_ = create();
    _this.offsetScaleMatrix_ = create();
    _this.tmpMat4_ = create2();
    _this.uniformLocations_ = {};
    _this.attribLocations_ = {};
    _this.uniforms_ = [];
    if (options.uniforms) {
      _this.setUniforms(options.uniforms);
    }
    var gl = _this.getGL();
    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function(options2) {
      return new PostProcessingPass_default({
        webGlContext: gl,
        scaleRatio: options2.scaleRatio,
        vertexShader: options2.vertexShader,
        fragmentShader: options2.fragmentShader,
        uniforms: options2.uniforms
      });
    }) : [new PostProcessingPass_default({ webGlContext: gl })];
    _this.shaderCompileErrors_ = null;
    _this.startTime_ = Date.now();
    return _this;
  }
  WebGLHelper2.prototype.setUniforms = function(uniforms) {
    this.uniforms_ = [];
    for (var name_1 in uniforms) {
      this.uniforms_.push({
        name: name_1,
        value: uniforms[name_1]
      });
    }
    this.uniformLocations_ = {};
  };
  WebGLHelper2.prototype.canvasCacheKeyMatches = function(canvasCacheKey) {
    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
  };
  WebGLHelper2.prototype.getExtension = function(name) {
    if (name in this.extensionCache_) {
      return this.extensionCache_[name];
    }
    var extension = this.gl_.getExtension(name);
    this.extensionCache_[name] = extension;
    return extension;
  };
  WebGLHelper2.prototype.bindBuffer = function(buffer) {
    var gl = this.getGL();
    var bufferKey = getUid(buffer);
    var bufferCache = this.bufferCache_[bufferKey];
    if (!bufferCache) {
      var webGlBuffer = gl.createBuffer();
      bufferCache = {
        buffer,
        webGlBuffer
      };
      this.bufferCache_[bufferKey] = bufferCache;
    }
    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
  };
  WebGLHelper2.prototype.flushBufferData = function(buffer) {
    var gl = this.getGL();
    this.bindBuffer(buffer);
    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
  };
  WebGLHelper2.prototype.deleteBuffer = function(buf) {
    var gl = this.getGL();
    var bufferKey = getUid(buf);
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    if (bufferCacheEntry && !gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
    }
    delete this.bufferCache_[bufferKey];
  };
  WebGLHelper2.prototype.disposeInternal = function() {
    this.canvas_.removeEventListener(ContextEventType_default.LOST, this.boundHandleWebGLContextLost_);
    this.canvas_.removeEventListener(ContextEventType_default.RESTORED, this.boundHandleWebGLContextRestored_);
    releaseCanvas(this.canvasCacheKey_);
    delete this.gl_;
    delete this.canvas_;
  };
  WebGLHelper2.prototype.prepareDraw = function(frameState, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var canvas = this.getCanvas();
    var size = frameState.size;
    var pixelRatio = frameState.pixelRatio;
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + "px";
    canvas.style.height = size[1] + "px";
    gl.useProgram(this.currentProgram_);
    for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {
      this.postProcessPasses_[i].init(frameState);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  WebGLHelper2.prototype.prepareDrawToRenderTarget = function(frameState, renderTarget, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var size = renderTarget.getSize();
    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
    gl.viewport(0, 0, size[0], size[1]);
    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  WebGLHelper2.prototype.drawElements = function(start, end) {
    var gl = this.getGL();
    this.getExtension("OES_element_index_uint");
    var elementType = gl.UNSIGNED_INT;
    var elementSize = 4;
    var numItems = end - start;
    var offsetInBytes = start * elementSize;
    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
  };
  WebGLHelper2.prototype.finalizeDraw = function(frameState, preCompose, postCompose) {
    for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {
      if (i === ii - 1) {
        this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);
      } else {
        this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);
      }
    }
  };
  WebGLHelper2.prototype.getCanvas = function() {
    return this.canvas_;
  };
  WebGLHelper2.prototype.getGL = function() {
    return this.gl_;
  };
  WebGLHelper2.prototype.applyFrameState = function(frameState) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var offsetScaleMatrix = reset(this.offsetScaleMatrix_);
    scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
    var offsetRotateMatrix = reset(this.offsetRotateMatrix_);
    if (rotation !== 0) {
      rotate(offsetRotateMatrix, -rotation);
    }
    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));
    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));
    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 1e-3);
    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
  };
  WebGLHelper2.prototype.applyUniforms = function(frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 0;
    this.uniforms_.forEach(function(uniform) {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.prevValue = void 0;
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var imageReady = !(value instanceof HTMLImageElement) || value.complete;
        if (imageReady && uniform.prevValue !== value) {
          uniform.prevValue = value;
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
      } else if (Array.isArray(value) && value.length === 6) {
        this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));
      } else if (Array.isArray(value) && value.length <= 4) {
        switch (value.length) {
          case 2:
            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(this.getUniformLocation(uniform.name), value);
      }
    }.bind(this));
  };
  WebGLHelper2.prototype.useProgram = function(program) {
    if (program == this.currentProgram_) {
      return false;
    } else {
      var gl = this.getGL();
      gl.useProgram(program);
      this.currentProgram_ = program;
      this.uniformLocations_ = {};
      this.attribLocations_ = {};
      return true;
    }
  };
  WebGLHelper2.prototype.compileShader = function(source, type) {
    var gl = this.getGL();
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  };
  WebGLHelper2.prototype.getProgram = function(fragmentShaderSource, vertexShaderSource) {
    var gl = this.getGL();
    var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    var program = gl.createProgram();
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      var message = "Fragment shader compliation failed: ".concat(gl.getShaderInfoLog(fragmentShader));
      throw new Error(message);
    }
    gl.deleteShader(fragmentShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      var message = "Vertex shader compilation failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }
    gl.deleteShader(vertexShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      var message = "GL program linking failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }
    return program;
  };
  WebGLHelper2.prototype.getUniformLocation = function(name) {
    if (this.uniformLocations_[name] === void 0) {
      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
    }
    return this.uniformLocations_[name];
  };
  WebGLHelper2.prototype.getAttributeLocation = function(name) {
    if (this.attribLocations_[name] === void 0) {
      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
    }
    return this.attribLocations_[name];
  };
  WebGLHelper2.prototype.makeProjectionTransform = function(frameState, transform) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var resolution = frameState.viewState.resolution;
    var center = frameState.viewState.center;
    reset(transform);
    compose(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
    return transform;
  };
  WebGLHelper2.prototype.setUniformFloatValue = function(uniform, value) {
    this.getGL().uniform1f(this.getUniformLocation(uniform), value);
  };
  WebGLHelper2.prototype.setUniformFloatVec4 = function(uniform, value) {
    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);
  };
  WebGLHelper2.prototype.setUniformMatrixValue = function(uniform, value) {
    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
  };
  WebGLHelper2.prototype.enableAttributeArray_ = function(attribName, size, type, stride, offset) {
    var location = this.getAttributeLocation(attribName);
    if (location < 0) {
      return;
    }
    this.getGL().enableVertexAttribArray(location);
    this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);
  };
  WebGLHelper2.prototype.enableAttributes = function(attributes) {
    var stride = computeAttributesStride(attributes);
    var offset = 0;
    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes[i];
      this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);
      offset += attr.size * getByteSizeFromType(attr.type);
    }
  };
  WebGLHelper2.prototype.handleWebGLContextLost = function() {
    clear(this.bufferCache_);
    this.currentProgram_ = null;
  };
  WebGLHelper2.prototype.handleWebGLContextRestored = function() {
  };
  WebGLHelper2.prototype.createTexture = function(size, opt_data, opt_texture) {
    var gl = this.getGL();
    var texture = opt_texture || gl.createTexture();
    var level = 0;
    var internalFormat = gl.RGBA;
    var border = 0;
    var format = gl.RGBA;
    var type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    if (opt_data) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return texture;
  };
  return WebGLHelper2;
}(Disposable_default);
function computeAttributesStride(attributes) {
  var stride = 0;
  for (var i = 0; i < attributes.length; i++) {
    var attr = attributes[i];
    stride += attr.size * getByteSizeFromType(attr.type);
  }
  return stride;
}
function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
var Helper_default = WebGLHelper;

// node_modules/ol/renderer/webgl/Layer.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WebGLLayerRenderer = function(_super) {
  __extends4(WebGLLayerRenderer2, _super);
  function WebGLLayerRenderer2(layer, opt_options) {
    var _this = _super.call(this, layer) || this;
    var options = opt_options || {};
    _this.inversePixelTransform_ = create();
    _this.pixelContext_ = null;
    _this.postProcesses_ = options.postProcesses;
    _this.uniforms_ = options.uniforms;
    _this.helper;
    layer.addChangeListener(Property_default.MAP, _this.removeHelper.bind(_this));
    _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);
    _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);
    return _this;
  }
  WebGLLayerRenderer2.prototype.dispatchPreComposeEvent = function(context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(EventType_default2.PRECOMPOSE)) {
      var event_1 = new Event_default(EventType_default2.PRECOMPOSE, void 0, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  WebGLLayerRenderer2.prototype.dispatchPostComposeEvent = function(context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(EventType_default2.POSTCOMPOSE)) {
      var event_2 = new Event_default(EventType_default2.POSTCOMPOSE, void 0, frameState, context);
      layer.dispatchEvent(event_2);
    }
  };
  WebGLLayerRenderer2.prototype.reset = function(options) {
    this.uniforms_ = options.uniforms;
    if (this.helper) {
      this.helper.setUniforms(this.uniforms_);
    }
  };
  WebGLLayerRenderer2.prototype.removeHelper = function() {
    if (this.helper) {
      this.helper.dispose();
      delete this.helper;
    }
  };
  WebGLLayerRenderer2.prototype.prepareFrame = function(frameState) {
    if (this.getLayer().getRenderSource()) {
      var incrementGroup = true;
      var groupNumber = -1;
      var className = void 0;
      for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {
        var layer = frameState.layerStatesArray[i].layer;
        var renderer = layer.getRenderer();
        if (!(renderer instanceof WebGLLayerRenderer2)) {
          incrementGroup = true;
          continue;
        }
        var layerClassName = layer.getClassName();
        if (incrementGroup || layerClassName !== className) {
          groupNumber += 1;
          incrementGroup = false;
        }
        className = layerClassName;
        if (renderer === this) {
          break;
        }
      }
      var canvasCacheKey = "map/" + frameState.mapId + "/group/" + groupNumber;
      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
        this.removeHelper();
        this.helper = new Helper_default({
          postProcesses: this.postProcesses_,
          uniforms: this.uniforms_,
          canvasCacheKey
        });
        if (className) {
          this.helper.getCanvas().className = className;
        }
        this.afterHelperCreated();
      }
    }
    return this.prepareFrameInternal(frameState);
  };
  WebGLLayerRenderer2.prototype.afterHelperCreated = function() {
  };
  WebGLLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    return true;
  };
  WebGLLayerRenderer2.prototype.disposeInternal = function() {
    this.removeHelper();
    _super.prototype.disposeInternal.call(this);
  };
  WebGLLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      compose(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
      var event_3 = new Event_default(type, this.inversePixelTransform_, frameState, context);
      layer.dispatchEvent(event_3);
    }
  };
  WebGLLayerRenderer2.prototype.preRender = function(context, frameState) {
    this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
  };
  WebGLLayerRenderer2.prototype.postRender = function(context, frameState) {
    this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
  };
  WebGLLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
    var renderPixel = apply([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());
    var gl = this.helper.getGL();
    if (!gl) {
      return null;
    }
    var layer = this.getLayer();
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      var renderCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
      if (!containsCoordinate(layerExtent, renderCoordinate)) {
        return null;
      }
    }
    var attributes = gl.getContextAttributes();
    if (!attributes || !attributes.preserveDrawingBuffer) {
      return new Uint8Array();
    }
    var x = Math.round(renderPixel[0]);
    var y = Math.round(renderPixel[1]);
    var pixelContext2 = this.pixelContext_;
    if (!pixelContext2) {
      var pixelCanvas = document.createElement("canvas");
      pixelCanvas.width = 1;
      pixelCanvas.height = 1;
      pixelContext2 = pixelCanvas.getContext("2d");
      this.pixelContext_ = pixelContext2;
    }
    pixelContext2.clearRect(0, 0, 1, 1);
    var data;
    try {
      pixelContext2.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);
      data = pixelContext2.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return data;
    }
    if (data[3] === 0) {
      return null;
    }
    return data;
  };
  return WebGLLayerRenderer2;
}(Layer_default2);
var Layer_default3 = WebGLLayerRenderer;

// node_modules/ol/renderer/webgl/TileLayer.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Uniforms = {
  TILE_TEXTURE_ARRAY: "u_tileTextures",
  TILE_TRANSFORM: "u_tileTransform",
  TRANSITION_ALPHA: "u_transitionAlpha",
  DEPTH: "u_depth",
  TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
  TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
  TEXTURE_RESOLUTION: "u_textureResolution",
  TEXTURE_ORIGIN_X: "u_textureOriginX",
  TEXTURE_ORIGIN_Y: "u_textureOriginY",
  RENDER_EXTENT: "u_renderExtent",
  RESOLUTION: "u_resolution",
  ZOOM: "u_zoom"
};
var Attributes = {
  TEXTURE_COORD: "a_textureCoord"
};
var attributeDescriptions = [
  {
    name: Attributes.TEXTURE_COORD,
    size: 2,
    type: AttributeType.FLOAT
  }
];
var empty = {};
function depthForZ(z) {
  return 2 * (1 - 1 / (z + 1)) - 1;
}
function addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {
  if (!(z in tileTexturesByZ)) {
    tileTexturesByZ[z] = [];
  }
  tileTexturesByZ[z].push(tileTexture);
}
function getRenderExtent(frameState, extent) {
  var layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));
  }
  var source = layerState.layer.getRenderSource();
  if (!source.getWrapX()) {
    var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = getIntersection(extent, gridExtent);
    }
  }
  return extent;
}
function getCacheKey(source, tileCoord) {
  return "".concat(source.getKey(), ",").concat(getKey(tileCoord));
}
var WebGLTileLayerRenderer = function(_super) {
  __extends5(WebGLTileLayerRenderer2, _super);
  function WebGLTileLayerRenderer2(tileLayer, options) {
    var _this = _super.call(this, tileLayer, {
      uniforms: options.uniforms
    }) || this;
    _this.renderComplete = false;
    _this.tileTransform_ = create();
    _this.tempMat4_ = create2();
    _this.tempTileRange_ = new TileRange_default(0, 0, 0, 0);
    _this.tempTileCoord_ = createOrUpdate(0, 0, 0);
    _this.tempSize_ = [0, 0];
    _this.program_;
    _this.vertexShader_ = options.vertexShader;
    _this.fragmentShader_ = options.fragmentShader;
    _this.indices_ = new Buffer_default(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);
    _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);
    var cacheSize = options.cacheSize !== void 0 ? options.cacheSize : 512;
    _this.tileTextureCache_ = new LRUCache_default(cacheSize);
    _this.paletteTextures_ = options.paletteTextures || [];
    _this.frameState_ = null;
    return _this;
  }
  WebGLTileLayerRenderer2.prototype.reset = function(options) {
    _super.prototype.reset.call(this, {
      uniforms: options.uniforms
    });
    this.vertexShader_ = options.vertexShader;
    this.fragmentShader_ = options.fragmentShader;
    this.paletteTextures_ = options.paletteTextures || [];
    if (this.helper) {
      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    }
  };
  WebGLTileLayerRenderer2.prototype.afterHelperCreated = function() {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    this.helper.flushBufferData(this.indices_);
  };
  WebGLTileLayerRenderer2.prototype.isDrawableTile_ = function(tile) {
    var tileLayer = this.getLayer();
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState_default.LOADED || tileState == TileState_default.EMPTY || tileState == TileState_default.ERROR && !useInterimTilesOnError;
  };
  WebGLTileLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    var layer = this.getLayer();
    var source = layer.getRenderSource();
    if (!source) {
      return false;
    }
    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {
      return false;
    }
    return source.getState() === State_default.READY;
  };
  WebGLTileLayerRenderer2.prototype.enqueueTiles = function(frameState, extent, initialZ, tileTexturesByZ) {
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var tilePixelRatio = tileSource.getTilePixelRatio(frameState.pixelRatio);
    var gutter = tileSource.getGutterForProjection(viewState.projection);
    var tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileTextureCache = this.tileTextureCache_;
    var minZ = Math.max(initialZ - tileLayer.getPreload(), tileGrid.getMinZoom(), tileLayer.getMinZoom());
    for (var z = initialZ; z >= minZ; --z) {
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);
      var tileResolution = tileGrid.getResolution(z);
      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          var tileCoord = createOrUpdate(z, x, y, this.tempTileCoord_);
          var cacheKey = getCacheKey(tileSource, tileCoord);
          var tileTexture = void 0;
          var tile = void 0;
          if (tileTextureCache.containsKey(cacheKey)) {
            tileTexture = tileTextureCache.get(cacheKey);
            tile = tileTexture.tile;
          }
          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {
            tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);
            if (!tileTexture) {
              tileTexture = new TileTexture_default({
                tile,
                grid: tileGrid,
                helper: this.helper,
                tilePixelRatio,
                gutter
              });
              tileTextureCache.set(cacheKey, tileTexture);
            } else {
              if (this.isDrawableTile_(tile)) {
                tileTexture.setTile(tile);
              } else {
                var interimTile = tile.getInterimTile();
                tileTexture.setTile(interimTile);
              }
            }
          }
          addTileTextureToLookup(tileTexturesByZ, tileTexture, z);
          var tileQueueKey = tile.getKey();
          wantedTiles[tileQueueKey] = true;
          if (tile.getState() === TileState_default.IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              frameState.tileQueue.enqueue([
                tile,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution
              ]);
            }
          }
        }
      }
    }
  };
  WebGLTileLayerRenderer2.prototype.renderFrame = function(frameState) {
    this.frameState_ = frameState;
    this.renderComplete = true;
    var gl = this.helper.getGL();
    this.preRender(gl, frameState);
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var extent = getRenderExtent(frameState, frameState.extent);
    var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    var tileTexturesByZ = {};
    if (frameState.nextExtent) {
      var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
      var nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);
    }
    this.enqueueTiles(frameState, extent, z, tileTexturesByZ);
    var alphaLookup = {};
    var uid = getUid(this);
    var time = frameState.time;
    var blend = false;
    var tileTextures = tileTexturesByZ[z];
    for (var i = 0, ii = tileTextures.length; i < ii; ++i) {
      var tileTexture = tileTextures[i];
      var tile = tileTexture.tile;
      var tileCoord = tile.tileCoord;
      if (tileTexture.loaded) {
        var alpha = tile.getAlpha(uid, time);
        if (alpha === 1) {
          tile.endTransition(uid);
          continue;
        }
        blend = true;
        var tileCoordKey = getKey(tileCoord);
        alphaLookup[tileCoordKey] = alpha;
      }
      this.renderComplete = false;
      var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);
      if (coveredByChildren) {
        continue;
      }
      var minZoom = tileGrid.getMinZoom();
      for (var parentZ = z - 1; parentZ >= minZoom; --parentZ) {
        var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);
        if (coveredByParent) {
          break;
        }
      }
    }
    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState, !blend);
    var zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);
    var centerX = viewState.center[0];
    var centerY = viewState.center[1];
    for (var j = 0, jj = zs.length; j < jj; ++j) {
      var tileZ = zs[j];
      var tileResolution = tileGrid.getResolution(tileZ);
      var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);
      var tileOrigin = tileGrid.getOrigin(tileZ);
      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
      var tileScale = viewState.resolution / tileResolution;
      var depth = depthForZ(tileZ);
      var tileTextures_1 = tileTexturesByZ[tileZ];
      for (var i = 0, ii = tileTextures_1.length; i < ii; ++i) {
        var tileTexture = tileTextures_1[i];
        if (!tileTexture.loaded) {
          continue;
        }
        var tile = tileTexture.tile;
        var tileCoord = tile.tileCoord;
        var tileCoordKey = getKey(tileCoord);
        var tileCenterI = tileCoord[1];
        var tileCenterJ = tileCoord[2];
        compose(this.tileTransform_, 0, 0, 2 / (frameState.size[0] * tileScale / tileSize[0]), -2 / (frameState.size[1] * tileScale / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));
        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, fromTransform(this.tempMat4_, this.tileTransform_));
        this.helper.bindBuffer(tileTexture.coords);
        this.helper.bindBuffer(this.indices_);
        this.helper.enableAttributes(attributeDescriptions);
        var textureSlot = 0;
        while (textureSlot < tileTexture.textures.length) {
          var textureProperty = "TEXTURE" + textureSlot;
          var uniformName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureSlot, "]");
          gl.activeTexture(gl[textureProperty]);
          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);
          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);
          ++textureSlot;
        }
        for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {
          var paletteTexture = this.paletteTextures_[paletteIndex];
          gl.activeTexture(gl["TEXTURE" + textureSlot]);
          var texture = paletteTexture.getTexture(gl);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);
          ++textureSlot;
        }
        var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;
        if (alpha < 1) {
          frameState.animate = true;
        }
        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution);
        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, extent);
        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
        this.helper.drawElements(0, this.indices_.getSize());
      }
    }
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    var canvas = this.helper.getCanvas();
    var tileTextureCache = this.tileTextureCache_;
    while (tileTextureCache.canExpireCache()) {
      var tileTexture = tileTextureCache.pop();
      tileTexture.dispose();
    }
    var postRenderFunction = function(map, frameState2) {
      tileSource.expireCache(frameState2.viewState.projection, empty);
    };
    frameState.postRenderFunctions.push(postRenderFunction);
    this.postRender(gl, frameState);
    return canvas;
  };
  WebGLTileLayerRenderer2.prototype.getData = function(pixel) {
    var gl = this.helper.getGL();
    if (!gl) {
      return null;
    }
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    var layer = this.getLayer();
    var coordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
    var viewState = frameState.viewState;
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {
        return null;
      }
    }
    var source = layer.getRenderSource();
    var tileGrid = source.getTileGridForProjection(viewState.projection);
    if (!source.getWrapX()) {
      var gridExtent = tileGrid.getExtent();
      if (gridExtent) {
        if (!containsCoordinate(gridExtent, coordinate)) {
          return null;
        }
      }
    }
    var tileTextureCache = this.tileTextureCache_;
    for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      var cacheKey = getCacheKey(source, tileCoord);
      if (!tileTextureCache.containsKey(cacheKey)) {
        continue;
      }
      var tileTexture = tileTextureCache.get(cacheKey);
      if (!tileTexture.loaded) {
        continue;
      }
      var tileOrigin = tileGrid.getOrigin(z);
      var tileSize = toSize(tileGrid.getTileSize(z));
      var tileResolution = tileGrid.getResolution(z);
      var col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
      var row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
      return tileTexture.getPixelData(col, row);
    }
    return null;
  };
  WebGLTileLayerRenderer2.prototype.findAltTiles_ = function(tileGrid, tileCoord, altZ, tileTexturesByZ) {
    var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
    if (!tileRange) {
      return false;
    }
    var covered = true;
    var tileTextureCache = this.tileTextureCache_;
    var source = this.getLayer().getRenderSource();
    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        var cacheKey = getCacheKey(source, [altZ, x, y]);
        var loaded = false;
        if (tileTextureCache.containsKey(cacheKey)) {
          var tileTexture = tileTextureCache.get(cacheKey);
          if (tileTexture.loaded) {
            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };
  WebGLTileLayerRenderer2.prototype.removeHelper = function() {
    if (this.helper) {
      var tileTextureCache = this.tileTextureCache_;
      tileTextureCache.forEach(function(tileTexture) {
        return tileTexture.dispose();
      });
      tileTextureCache.clear();
    }
    _super.prototype.removeHelper.call(this);
  };
  WebGLTileLayerRenderer2.prototype.disposeInternal = function() {
    var helper = this.helper;
    if (helper) {
      var gl = helper.getGL();
      gl.deleteProgram(this.program_);
      delete this.program_;
      helper.deleteBuffer(this.indices_);
    }
    _super.prototype.disposeInternal.call(this);
    delete this.indices_;
    delete this.tileTextureCache_;
    delete this.frameState_;
  };
  return WebGLTileLayerRenderer2;
}(Layer_default3);
var TileLayer_default = WebGLTileLayerRenderer;

// node_modules/ol/webgl/PaletteTexture.js
var PaletteTexture = function() {
  function PaletteTexture2(name, data) {
    this.name = name;
    this.data = data;
    this.texture_ = null;
  }
  PaletteTexture2.prototype.getTexture = function(gl) {
    if (!this.texture_) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
      this.texture_ = texture;
    }
    return this.texture_;
  };
  return PaletteTexture2;
}();
var PaletteTexture_default = PaletteTexture;

// node_modules/ol/style/expressions.js
var ValueTypes = {
  NUMBER: 1,
  STRING: 2,
  COLOR: 4,
  BOOLEAN: 8,
  NUMBER_ARRAY: 16,
  ANY: 31,
  NONE: 0
};
var Operators = {};
function getValueType(value) {
  if (typeof value === "number") {
    return ValueTypes.NUMBER;
  }
  if (typeof value === "boolean") {
    return ValueTypes.BOOLEAN;
  }
  if (typeof value === "string") {
    if (isStringColor(value)) {
      return ValueTypes.COLOR | ValueTypes.STRING;
    }
    return ValueTypes.STRING;
  }
  if (!Array.isArray(value)) {
    throw new Error("Unhandled value type: ".concat(JSON.stringify(value)));
  }
  var valueArr = value;
  var onlyNumbers = valueArr.every(function(v) {
    return typeof v === "number";
  });
  if (onlyNumbers) {
    if (valueArr.length === 3 || valueArr.length === 4) {
      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;
    }
    return ValueTypes.NUMBER_ARRAY;
  }
  if (typeof valueArr[0] !== "string") {
    throw new Error("Expected an expression operator but received: ".concat(JSON.stringify(valueArr)));
  }
  var operator = Operators[valueArr[0]];
  if (operator === void 0) {
    throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(valueArr)));
  }
  return operator.getReturnType(valueArr.slice(1));
}
function isTypeUnique(valueType) {
  return log2(valueType) % 1 === 0;
}
function numberToGlsl(v) {
  var s = v.toString();
  return s.indexOf(".") === -1 ? s + ".0" : s;
}
function arrayToGlsl(array) {
  if (array.length < 2 || array.length > 4) {
    throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
  }
  return "vec".concat(array.length, "(").concat(array.map(numberToGlsl).join(", "), ")");
}
function colorToGlsl(color) {
  var array = asArray(color).slice();
  if (array.length < 4) {
    array.push(1);
  }
  return arrayToGlsl(array.map(function(c, i) {
    return i < 3 ? c / 255 : c;
  }));
}
function getStringNumberEquivalent(context, string) {
  if (context.stringLiteralsMap[string] === void 0) {
    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;
  }
  return context.stringLiteralsMap[string];
}
function stringToGlsl(context, string) {
  return numberToGlsl(getStringNumberEquivalent(context, string));
}
function expressionToGlsl(context, value, typeHint) {
  if (Array.isArray(value) && typeof value[0] === "string") {
    var operator = Operators[value[0]];
    if (operator === void 0) {
      throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(value)));
    }
    return operator.toGlsl(context, value.slice(1), typeHint);
  }
  var valueType = getValueType(value);
  if ((valueType & ValueTypes.NUMBER) > 0) {
    return numberToGlsl(value);
  }
  if ((valueType & ValueTypes.BOOLEAN) > 0) {
    return value.toString();
  }
  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === void 0 || typeHint == ValueTypes.STRING)) {
    return stringToGlsl(context, value.toString());
  }
  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === void 0 || typeHint == ValueTypes.COLOR)) {
    return colorToGlsl(value);
  }
  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {
    return arrayToGlsl(value);
  }
  throw new Error("Unexpected expression ".concat(value, " (expected type ").concat(typeHint, ")"));
}
function assertNumber(value) {
  if (!(getValueType(value) & ValueTypes.NUMBER)) {
    throw new Error("A numeric value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertNumbers(values) {
  for (var i = 0; i < values.length; i++) {
    assertNumber(values[i]);
  }
}
function assertString(value) {
  if (!(getValueType(value) & ValueTypes.STRING)) {
    throw new Error("A string value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertBoolean(value) {
  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {
    throw new Error("A boolean value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertArgsCount(args, count) {
  if (args.length !== count) {
    throw new Error("Exactly ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsMinCount(args, count) {
  if (args.length < count) {
    throw new Error("At least ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsMaxCount(args, count) {
  if (args.length > count) {
    throw new Error("At most ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsEven(args) {
  if (args.length % 2 !== 0) {
    throw new Error("An even amount of arguments was expected, got ".concat(args, " instead"));
  }
}
function assertArgsOdd(args) {
  if (args.length % 2 === 0) {
    throw new Error("An odd amount of arguments was expected, got ".concat(args, " instead"));
  }
}
function assertUniqueInferredType(args, types) {
  if (!isTypeUnique(types)) {
    throw new Error("Could not infer only one type from the following expression: ".concat(JSON.stringify(args)));
  }
}
Operators["get"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();
    if (context.attributes.indexOf(value) === -1) {
      context.attributes.push(value);
    }
    var prefix = context.inFragmentShader ? "v_" : "a_";
    return prefix + value;
  }
};
function uniformNameForVariable(variableName) {
  return "u_var_" + variableName;
}
Operators["var"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();
    if (context.variables.indexOf(value) === -1) {
      context.variables.push(value);
    }
    return uniformNameForVariable(value);
  }
};
var PALETTE_TEXTURE_ARRAY = "u_paletteTextures";
Operators["palette"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumber(args[0]);
    var index = expressionToGlsl(context, args[0]);
    var colors = args[1];
    if (!Array.isArray(colors)) {
      throw new Error("The second argument of palette must be an array");
    }
    var numColors = colors.length;
    var palette = new Uint8Array(numColors * 4);
    for (var i = 0; i < numColors; i++) {
      var candidate = colors[i];
      var color = void 0;
      if (typeof candidate === "string") {
        color = fromString(candidate);
      } else {
        if (!Array.isArray(candidate)) {
          throw new Error("The second argument of palette must be an array of strings or colors");
        }
        var length_1 = candidate.length;
        if (length_1 === 4) {
          color = candidate;
        } else {
          if (length_1 !== 3) {
            throw new Error("Expected palette color to have 3 or 4 values, got ".concat(length_1));
          }
          color = [candidate[0], candidate[1], candidate[2], 1];
        }
      }
      var offset = i * 4;
      palette[offset] = color[0];
      palette[offset + 1] = color[1];
      palette[offset + 2] = color[2];
      palette[offset + 3] = color[3] * 255;
    }
    if (!context.paletteTextures) {
      context.paletteTextures = [];
    }
    var paletteName = "".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "]");
    var paletteTexture = new PaletteTexture_default(paletteName, palette);
    context.paletteTextures.push(paletteTexture);
    return "texture2D(".concat(paletteName, ", vec2((").concat(index, " + 0.5) / ").concat(numColors, ".0, 0.5))");
  }
};
var GET_BAND_VALUE_FUNC = "getBandValue";
Operators["band"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 3);
    var band = args[0];
    if (!(GET_BAND_VALUE_FUNC in context.functions)) {
      var ifBlocks = "";
      var bandCount = context.bandCount || 1;
      for (var i = 0; i < bandCount; i++) {
        var colorIndex = Math.floor(i / 4);
        var bandIndex = i % 4;
        if (bandIndex === bandCount - 1 && bandIndex === 1) {
          bandIndex = 3;
        }
        var textureName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(colorIndex, "]");
        ifBlocks += "\n          if (band == ".concat(i + 1, ".0) {\n            return texture2D(").concat(textureName, ", v_textureCoord + vec2(dx, dy))[").concat(bandIndex, "];\n          }\n        ");
      }
      context.functions[GET_BAND_VALUE_FUNC] = "\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ".concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n          float dy = yOffset / ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n          ").concat(ifBlocks, "\n        }\n      ");
    }
    var bandExpression = expressionToGlsl(context, band);
    var xOffsetExpression = expressionToGlsl(context, args[1] || 0);
    var yOffsetExpression = expressionToGlsl(context, args[2] || 0);
    return "".concat(GET_BAND_VALUE_FUNC, "(").concat(bandExpression, ", ").concat(xOffsetExpression, ", ").concat(yOffsetExpression, ")");
  }
};
Operators["time"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_time";
  }
};
Operators["zoom"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_zoom";
  }
};
Operators["resolution"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_resolution";
  }
};
Operators["*"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " * ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["/"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " / ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["+"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " + ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["-"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " - ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["clamp"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min = expressionToGlsl(context, args[1]);
    var max = expressionToGlsl(context, args[2]);
    return "clamp(".concat(expressionToGlsl(context, args[0]), ", ").concat(min, ", ").concat(max, ")");
  }
};
Operators["%"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "mod(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["^"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "pow(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["abs"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "abs(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["floor"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["round"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), " + 0.5)");
  }
};
Operators["ceil"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "ceil(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["sin"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "sin(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["cos"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "cos(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["atan"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 2);
    assertNumbers(args);
    return args.length === 2 ? "atan(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")") : "atan(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators[">"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " > ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators[">="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " >= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["<"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " < ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["<="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " <= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
function getEqualOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
      assertArgsCount(args, 2);
      var type = ValueTypes.ANY;
      for (var i = 0; i < args.length; i++) {
        type &= getValueType(args[i]);
      }
      if (type === ValueTypes.NONE) {
        throw new Error("All arguments should be of compatible type, got ".concat(JSON.stringify(args), " instead"));
      }
      type &= ~ValueTypes.COLOR;
      return "(".concat(expressionToGlsl(context, args[0], type), " ").concat(operator, " ").concat(expressionToGlsl(context, args[1], type), ")");
    }
  };
}
Operators["=="] = getEqualOperator("==");
Operators["!="] = getEqualOperator("!=");
Operators["!"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertBoolean(args[0]);
    return "(!".concat(expressionToGlsl(context, args[0]), ")");
  }
};
function getDecisionOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
      assertArgsMinCount(args, 2);
      for (var i = 0; i < args.length; i++) {
        assertBoolean(args[i]);
      }
      var result = "";
      result = args.map(function(arg) {
        return expressionToGlsl(context, arg);
      }).join(" ".concat(operator, " "));
      result = "(".concat(result, ")");
      return result;
    }
  };
}
Operators["all"] = getDecisionOperator("&&");
Operators["any"] = getDecisionOperator("||");
Operators["between"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min = expressionToGlsl(context, args[1]);
    var max = expressionToGlsl(context, args[2]);
    var value = expressionToGlsl(context, args[0]);
    return "(".concat(value, " >= ").concat(min, " && ").concat(value, " <= ").concat(max, ")");
  }
};
Operators["array"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER_ARRAY;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 2);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var parsedArgs = args.map(function(val) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER);
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(", "), ")");
  }
};
Operators["color"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 3);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var array = args;
    if (args.length === 3) {
      array.push(1);
    }
    var parsedArgs = args.map(function(val, i) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? " / 255.0" : "");
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(", "), ")");
  }
};
Operators["interpolate"] = {
  getReturnType: function(args) {
    var type = ValueTypes.COLOR | ValueTypes.NUMBER;
    for (var i = 3; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 6);
    var type = args[0];
    var interpolation;
    switch (type[0]) {
      case "linear":
        interpolation = 1;
        break;
      case "exponential":
        interpolation = type[1];
        break;
      default:
        interpolation = null;
    }
    if (!interpolation) {
      throw new Error('Invalid interpolation type for "interpolate" operator, received: '.concat(JSON.stringify(type)));
    }
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["interpolate"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[1]);
    var exponent = numberToGlsl(interpolation);
    var result = "";
    for (var i = 2; i < args.length - 2; i += 2) {
      var stop1 = expressionToGlsl(context, args[i]);
      var output1 = result || expressionToGlsl(context, args[i + 1], outputType);
      var stop2 = expressionToGlsl(context, args[i + 2]);
      var output2 = expressionToGlsl(context, args[i + 3], outputType);
      result = "mix(".concat(output1, ", ").concat(output2, ", pow(clamp((").concat(input, " - ").concat(stop1, ") / (").concat(stop2, " - ").concat(stop1, "), 0.0, 1.0), ").concat(exponent, "))");
    }
    return result;
  }
};
Operators["match"] = {
  getReturnType: function(args) {
    var type = ValueTypes.ANY;
    for (var i = 2; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 4);
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["match"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[0]);
    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;
    for (var i = args.length - 3; i >= 1; i -= 2) {
      var match = expressionToGlsl(context, args[i]);
      var output = expressionToGlsl(context, args[i + 1], outputType);
      result = "(".concat(input, " == ").concat(match, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }
    return result;
  }
};
Operators["case"] = {
  getReturnType: function(args) {
    var type = ValueTypes.ANY;
    for (var i = 1; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsOdd(args);
    assertArgsMinCount(args, 3);
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["case"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    for (var i = 0; i < args.length - 1; i += 2) {
      assertBoolean(args[i]);
    }
    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;
    for (var i = args.length - 3; i >= 0; i -= 2) {
      var condition = expressionToGlsl(context, args[i]);
      var output = expressionToGlsl(context, args[i + 1], outputType);
      result = "(".concat(condition, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }
    return result;
  }
};

// node_modules/ol/layer/WebGLTile.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function parseStyle(style, bandCount) {
  var vertexShader = "\n    attribute vec2 ".concat(Attributes.TEXTURE_COORD, ";\n    uniform mat4 ").concat(Uniforms.TILE_TRANSFORM, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(Uniforms.TEXTURE_RESOLUTION, ";\n    uniform float ").concat(Uniforms.TEXTURE_ORIGIN_X, ";\n    uniform float ").concat(Uniforms.TEXTURE_ORIGIN_Y, ";\n    uniform float ").concat(Uniforms.DEPTH, ";\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ").concat(Attributes.TEXTURE_COORD, ";\n      v_mapCoord = vec2(\n        ").concat(Uniforms.TEXTURE_ORIGIN_X, " + ").concat(Uniforms.TEXTURE_RESOLUTION, " * ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, " * v_textureCoord[0],\n        ").concat(Uniforms.TEXTURE_ORIGIN_Y, " - ").concat(Uniforms.TEXTURE_RESOLUTION, " * ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, " * v_textureCoord[1]\n      );\n      gl_Position = ").concat(Uniforms.TILE_TRANSFORM, " * vec4(").concat(Attributes.TEXTURE_COORD, ", ").concat(Uniforms.DEPTH, ", 1.0);\n    }\n  ");
  var context = {
    inFragmentShader: true,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {},
    bandCount
  };
  var pipeline = [];
  if (style.color !== void 0) {
    var color = expressionToGlsl(context, style.color, ValueTypes.COLOR);
    pipeline.push("color = ".concat(color, ";"));
  }
  if (style.contrast !== void 0) {
    var contrast = expressionToGlsl(context, style.contrast, ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp((".concat(contrast, " + 1.0) * color.rgb - (").concat(contrast, " / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  if (style.exposure !== void 0) {
    var exposure = expressionToGlsl(context, style.exposure, ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp((".concat(exposure, " + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  if (style.saturation !== void 0) {
    var saturation = expressionToGlsl(context, style.saturation, ValueTypes.NUMBER);
    pipeline.push("\n      float saturation = ".concat(saturation, " + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    "));
  }
  if (style.gamma !== void 0) {
    var gamma = expressionToGlsl(context, style.gamma, ValueTypes.NUMBER);
    pipeline.push("color.rgb = pow(color.rgb, vec3(1.0 / ".concat(gamma, "));"));
  }
  if (style.brightness !== void 0) {
    var brightness = expressionToGlsl(context, style.brightness, ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp(color.rgb + ".concat(brightness, ", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  var uniforms = {};
  var numVariables = context.variables.length;
  if (numVariables > 1 && !style.variables) {
    throw new Error("Missing variables in style (expected ".concat(context.variables, ")"));
  }
  var _loop_1 = function(i2) {
    var variableName = context.variables[i2];
    if (!(variableName in style.variables)) {
      throw new Error("Missing '".concat(variableName, "' in style variables"));
    }
    var uniformName = uniformNameForVariable(variableName);
    uniforms[uniformName] = function() {
      var value = style.variables[variableName];
      if (typeof value === "string") {
        value = getStringNumberEquivalent(context, value);
      }
      return value !== void 0 ? value : -9999999;
    };
  };
  for (var i = 0; i < numVariables; ++i) {
    _loop_1(i);
  }
  var uniformDeclarations = Object.keys(uniforms).map(function(name) {
    return "uniform float ".concat(name, ";");
  });
  var textureCount = Math.ceil(bandCount / 4);
  uniformDeclarations.push("uniform sampler2D ".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureCount, "];"));
  if (context.paletteTextures) {
    uniformDeclarations.push("uniform sampler2D ".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "];"));
  }
  var functionDefintions = Object.keys(context.functions).map(function(name) {
    return context.functions[name];
  });
  var fragmentShader = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ".concat(Uniforms.RENDER_EXTENT, ";\n    uniform float ").concat(Uniforms.TRANSITION_ALPHA, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(Uniforms.RESOLUTION, ";\n    uniform float ").concat(Uniforms.ZOOM, ";\n\n    ").concat(uniformDeclarations.join("\n"), "\n\n    ").concat(functionDefintions.join("\n"), "\n\n    void main() {\n      if (\n        v_mapCoord[0] < ").concat(Uniforms.RENDER_EXTENT, "[0] ||\n        v_mapCoord[1] < ").concat(Uniforms.RENDER_EXTENT, "[1] ||\n        v_mapCoord[0] > ").concat(Uniforms.RENDER_EXTENT, "[2] ||\n        v_mapCoord[1] > ").concat(Uniforms.RENDER_EXTENT, "[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(").concat(Uniforms.TILE_TEXTURE_ARRAY, "[0],  v_textureCoord);\n\n      ").concat(pipeline.join("\n"), "\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ").concat(Uniforms.TRANSITION_ALPHA, ";\n    }");
  return {
    vertexShader,
    fragmentShader,
    uniforms,
    paletteTextures: context.paletteTextures
  };
}
var WebGLTileLayer = function(_super) {
  __extends6(WebGLTileLayer2, _super);
  function WebGLTileLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? assign({}, opt_options) : {};
    var style = options.style || {};
    delete options.style;
    var cacheSize = options.cacheSize;
    delete options.cacheSize;
    _this = _super.call(this, options) || this;
    _this.sources_ = options.sources;
    _this.renderedSource_ = null;
    _this.renderedResolution_ = NaN;
    _this.style_ = style;
    _this.cacheSize_ = cacheSize;
    _this.styleVariables_ = _this.style_.variables || {};
    _this.addChangeListener(Property_default.SOURCE, _this.handleSourceUpdate_);
    return _this;
  }
  WebGLTileLayer2.prototype.getSources = function(extent, resolution) {
    var source = this.getSource();
    return this.sources_ ? typeof this.sources_ === "function" ? this.sources_(extent, resolution) : this.sources_ : source ? [source] : [];
  };
  WebGLTileLayer2.prototype.getRenderSource = function() {
    return this.renderedSource_ || this.getSource();
  };
  WebGLTileLayer2.prototype.getSourceState = function() {
    var source = this.getRenderSource();
    return source ? source.getState() : State_default.UNDEFINED;
  };
  WebGLTileLayer2.prototype.handleSourceUpdate_ = function() {
    if (this.getSource()) {
      this.setStyle(this.style_);
    }
  };
  WebGLTileLayer2.prototype.getSourceBandCount_ = function() {
    var source = this.getSource();
    return source && "bandCount" in source ? source.bandCount : 4;
  };
  WebGLTileLayer2.prototype.createRenderer = function() {
    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    return new TileLayer_default(this, {
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      cacheSize: this.cacheSize_,
      paletteTextures: parsedStyle.paletteTextures
    });
  };
  WebGLTileLayer2.prototype.renderSources = function(frameState, sources) {
    var layerRenderer = this.getRenderer();
    var canvas;
    for (var i = 0, ii = sources.length; i < ii; ++i) {
      this.renderedSource_ = sources[i];
      if (layerRenderer.prepareFrame(frameState)) {
        canvas = layerRenderer.renderFrame(frameState);
      }
    }
    return canvas;
  };
  WebGLTileLayer2.prototype.render = function(frameState, target) {
    var _this = this;
    this.rendered = true;
    var viewState = frameState.viewState;
    var sources = this.getSources(frameState.extent, viewState.resolution);
    var ready = true;
    var _loop_2 = function(i2, ii2) {
      var source = sources[i2];
      var sourceState = source.getState();
      if (sourceState == State_default.LOADING) {
        var onChange_1 = function() {
          if (source.getState() == State_default.READY) {
            source.removeEventListener("change", onChange_1);
            _this.changed();
          }
        };
        source.addEventListener("change", onChange_1);
      }
      ready = ready && sourceState == State_default.READY;
    };
    for (var i = 0, ii = sources.length; i < ii; ++i) {
      _loop_2(i, ii);
    }
    var canvas = this.renderSources(frameState, sources);
    if (this.getRenderer().renderComplete && ready) {
      this.renderedResolution_ = viewState.resolution;
      return canvas;
    }
    if (this.renderedResolution_ > 0.5 * viewState.resolution) {
      var altSources = this.getSources(frameState.extent, this.renderedResolution_).filter(function(source) {
        return !sources.includes(source);
      });
      if (altSources.length > 0) {
        return this.renderSources(frameState, altSources);
      }
    }
    return canvas;
  };
  WebGLTileLayer2.prototype.setStyle = function(style) {
    this.styleVariables_ = style.variables || {};
    this.style_ = style;
    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    var renderer = this.getRenderer();
    renderer.reset({
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      paletteTextures: parsedStyle.paletteTextures
    });
    this.changed();
  };
  WebGLTileLayer2.prototype.updateStyleVariables = function(variables) {
    assign(this.styleVariables_, variables);
    this.changed();
  };
  return WebGLTileLayer2;
}(BaseTile_default);
WebGLTileLayer.prototype.dispose;
var WebGLTile_default = WebGLTileLayer;

// dep:ol_layer_WebGLTile
var ol_layer_WebGLTile_default = WebGLTile_default;
export {
  ol_layer_WebGLTile_default as default
};
//# sourceMappingURL=ol_layer_WebGLTile.js.map
